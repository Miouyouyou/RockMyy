From 7a88fd911e3a423257b4453fb20374ed0f58d26e Mon Sep 17 00:00:00 2001
From: Myy <myy@miouyouyou.fr>
Date: Sat, 22 Jul 2017 02:46:14 +0000
Subject: [PATCH] Fugly MMC hack, trying to resolve Tinkerboard's reboot issue

We can do uglier !

Signed-off-by: Myy <myy@miouyouyou.fr>
---
 drivers/mmc/host/dw_mmc-rockchip.c | 22 +++++++++++++++++-----
 drivers/mmc/host/dw_mmc.c          | 25 +++++++++++++++++++++++++
 include/linux/reboot.h             |  4 ++++
 kernel/reboot.c                    |  1 +
 4 files changed, 47 insertions(+), 5 deletions(-)

diff --git a/drivers/mmc/host/dw_mmc-rockchip.c b/drivers/mmc/host/dw_mmc-rockchip.c
index 57ffb6a..04fdbf9 100644
--- a/drivers/mmc/host/dw_mmc-rockchip.c
+++ b/drivers/mmc/host/dw_mmc-rockchip.c
@@ -407,23 +407,35 @@ static void dw_mci_rockchip_platfm_shutdown(struct platform_device *pdev)
 	struct mmc_host *mmc = host->slot->mmc;
 
 	int ret;
-	
+
 	printk(
 		KERN_ERR "( Myy ) Powering the MMC hardware OFF ! (Hack)\n"
 	);
+	printk(
+		KERN_ERR "( Myy ) Node name : %s\n",
+		host->dev->of_node->full_name
+	);
 	mmc_power_off(mmc);
 	mdelay(20);
-	
+
 	if (!IS_ERR(mmc->supply.vmmc)) {
 		ret = regulator_enable(mmc->supply.vmmc);
 		printk(
 			KERN_ERR "( Myy ) Re-enabling the MMC regulator -> %d\n", ret
 		);
+		printk(
+			KERN_ERR "( Myy ) Regulator enabled !? %d\n",
+			mmc->regulator_enabled
+		);
 	}
-	
+
 	if (!IS_ERR(mmc->supply.vqmmc)) {
 		ret = regulator_set_voltage(mmc->supply.vqmmc, 3000000, 3300000);
 		printk(KERN_ERR "( Myy ) Modified the MMC Voltage -> %d\n", ret);
+		printk(
+			KERN_ERR "( Myy ) Current voltage -> %d\n",
+			regulator_get_voltage(mmc->supply.vqmmc)
+		);
 	}
 }
 
@@ -434,11 +446,11 @@ static int dw_mci_rockchip_setup_tinker_reboot_fix(char *str)
 		dw_mci_rockchip_pltfm_driver.shutdown = 
 			dw_mci_rockchip_platfm_shutdown;
 	}
-	else 
+	else
 		printk(
 			KERN_INFO "( Myy ) Not enabling Tinkerboard's reboot fix\n"
 		);
-	
+
 	return 0;
 }
 
diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index a9dfb26..121bc0a 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -42,6 +42,10 @@
 
 #include "dw_mmc.h"
 
+// For ASUS reboot hack
+#include <linux/reboot.h>
+#include "../core/core.h" // ... Yeah ...
+
 /* Common flag combinations */
 #define DW_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DRTO | SDMMC_INT_DCRC | \
 				 SDMMC_INT_HTO | SDMMC_INT_SBE  | \
@@ -2687,6 +2691,24 @@ static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+struct dw_mci *mSdhost;
+void setmmcEmergency() {
+	struct mmc_host *mmc = mSdhost->slot->mmc;
+	int ret;
+
+	mmc_power_off(mmc);
+	mdelay(20);
+
+	if (!IS_ERR(mmc->supply.vmmc))  {
+		ret = regulator_enable(mmc->supply.vmmc);
+	}
+
+	if (!IS_ERR(mmc->supply.vqmmc))
+		regulator_set_voltage(mmc->supply.vqmmc, 3000000, 3300000);
+
+}
+EXPORT_SYMBOL(setmmcEmergency);
+
 static int dw_mci_init_slot(struct dw_mci *host)
 {
 	struct mmc_host *mmc;
@@ -2718,6 +2740,9 @@ static int dw_mci_init_slot(struct dw_mci *host)
 		mmc->f_max = freq[1];
 	}
 
+		if (of_find_property(host->dev->of_node, "supports-sd", NULL))
+			mSdhost = host;
+
 	/*if there are external regulators, get them*/
 	ret = mmc_regulator_get_supply(mmc);
 	if (ret == -EPROBE_DEFER)
diff --git a/include/linux/reboot.h b/include/linux/reboot.h
index a7ff409..9e5addb 100644
--- a/include/linux/reboot.h
+++ b/include/linux/reboot.h
@@ -78,6 +78,10 @@ extern void orderly_reboot(void);
  */
 
 extern void emergency_restart(void);
+
+// Stupid ASUS Hack
+extern void setmmcEmergency(void);
+
 #include <asm/emergency-restart.h>
 
 #endif /* _LINUX_REBOOT_H */
diff --git a/kernel/reboot.c b/kernel/reboot.c
index bd30a97..9f99488 100644
--- a/kernel/reboot.c
+++ b/kernel/reboot.c
@@ -61,6 +61,7 @@ void (*pm_power_off_prepare)(void);
 void emergency_restart(void)
 {
 	kmsg_dump(KMSG_DUMP_EMERG);
+	setmmcEmergency();
 	machine_emergency_restart();
 }
 EXPORT_SYMBOL_GPL(emergency_restart);
-- 
2.10.2

