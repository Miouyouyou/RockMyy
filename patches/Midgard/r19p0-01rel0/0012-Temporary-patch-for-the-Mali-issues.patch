From b8b4010bbfd40ac6af569317928fe3d4233f3825 Mon Sep 17 00:00:00 2001
From: "Miouyouyou (Myy)" <myy@miouyouyou.fr>
Date: Sun, 18 Nov 2018 22:22:28 +0100
Subject: [PATCH] Temporary patch for the Mali issues

But that does not resolve all issues and, it clearly impacts the driver
performances.

Also, some DMA error on the sound subsystem showed up but I don't know
if that's related to this, or just due to the fact that X11 can now start
correctly.

Anyway, you can at least get to X11 and "kinda" use OpenGL ES, but with
degrade performances (From 0 to 1/2 Vsync).

Signed-off-by: Miouyouyou (Myy) <myy@miouyouyou.fr>
---
 drivers/gpu/arm/midgard/mali_kbase_mem_linux.c | 31 ++++++++++++++++----------
 1 file changed, 19 insertions(+), 12 deletions(-)

diff --git a/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c b/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
index 87708aa99..c89e9993e 100644
--- a/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
@@ -1792,7 +1792,7 @@ KBASE_EXPORT_TEST_API(kbase_cpu_vm_close);
 static int kbase_cpu_vm_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
 #else
-static int kbase_cpu_vm_fault(struct vm_fault *vmf)
+static vm_fault_t kbase_cpu_vm_fault(struct vm_fault *vmf)
 {
 	struct vm_area_struct *vma = vmf->vma;
 #endif
@@ -1800,6 +1800,7 @@ static int kbase_cpu_vm_fault(struct vm_fault *vmf)
 	pgoff_t rel_pgoff;
 	size_t i;
 	pgoff_t addr;
+	vm_fault_t ret = VM_FAULT_NOPAGE;
 
 	KBASE_DEBUG_ASSERT(map);
 	KBASE_DEBUG_ASSERT(map->count > 0);
@@ -1809,12 +1810,16 @@ static int kbase_cpu_vm_fault(struct vm_fault *vmf)
 	rel_pgoff = vmf->pgoff - map->region->start_pfn;
 
 	kbase_gpu_vm_lock(map->kctx);
-	if (rel_pgoff >= map->alloc->nents)
+	if (rel_pgoff >= map->alloc->nents) {
+		ret = VM_FAULT_SIGBUS;
 		goto locked_bad_fault;
+	}
 
 	/* Fault on access to DONT_NEED regions */
-	if (map->alloc->reg && (map->alloc->reg->flags & KBASE_REG_DONT_NEED))
+	if (map->alloc->reg && (map->alloc->reg->flags & KBASE_REG_DONT_NEED)) {
+		ret = VM_FAULT_SIGBUS;
 		goto locked_bad_fault;
+	}
 
 	/* insert all valid pages from the fault location */
 	i = rel_pgoff;
@@ -1826,19 +1831,20 @@ static int kbase_cpu_vm_fault(struct vm_fault *vmf)
 	while (i < map->alloc->nents && (addr < vma->vm_end >> PAGE_SHIFT)) {
 		int ret = vmf_insert_pfn(vma, addr << PAGE_SHIFT,
 		    PFN_DOWN(as_phys_addr_t(map->alloc->pages[i])));
-		if (ret < 0 && ret != -EBUSY)
-			goto locked_bad_fault;
+		if (unlikely(ret == VM_FAULT_NOPAGE && i > 0))
+			break;
+		else if (unlikely(ret & VM_FAULT_ERROR)) {
+			WARN_ON(ret);
+			break;
+		}
 
 		i++; addr++;
 	}
 
 	kbase_gpu_vm_unlock(map->kctx);
 	/* we resolved it, nothing for VM to do */
-	return VM_FAULT_NOPAGE;
-
 locked_bad_fault:
-	kbase_gpu_vm_unlock(map->kctx);
-	return VM_FAULT_SIGBUS;
+	return ret;
 }
 
 const struct vm_operations_struct kbase_vm_ops = {
@@ -1853,6 +1859,7 @@ static int kbase_cpu_mmap(struct kbase_va_region *reg, struct vm_area_struct *vm
 	struct tagged_addr *page_array;
 	int err = 0;
 	int i;
+	vm_fault_t insert_pfn_issue = 0;
 
 	map = kzalloc(sizeof(*map), GFP_KERNEL);
 
@@ -1907,8 +1914,8 @@ static int kbase_cpu_mmap(struct kbase_va_region *reg, struct vm_area_struct *vm
 			phys_addr_t phys;
 
 			phys = as_phys_addr_t(page_array[i + start_off]);
-			err = vmf_insert_pfn(vma, addr, PFN_DOWN(phys));
-			if (WARN_ON(err))
+			insert_pfn_issue = vmf_insert_pfn(vma, addr, PFN_DOWN(phys));
+			if (insert_pfn_issue == VM_FAULT_NOPAGE)
 				break;
 
 			addr += PAGE_SIZE;
@@ -1922,7 +1929,7 @@ static int kbase_cpu_mmap(struct kbase_va_region *reg, struct vm_area_struct *vm
 		WARN_ON(err);
 	}
 
-	if (err) {
+	if (err || insert_pfn_issue) {
 		kfree(map);
 		goto out;
 	}
-- 
2.16.4

